import 'dart:async';
import 'dart:io';
import 'dart:isolate';

void main(List<String> args) async {
  // Simple Isolate Example: Listens to two streams respectively - generated by an Isolate.
  // Each stream is limited to the first 10 messages using `take(10)`. Iterates over each message in these streams and prints them to the console.
  final messageStream1 = getMessages1().take(10);
  await for (final message in messageStream1) {
    print(message);
  }

  print('-----------------');

  final messageStream2 = getMessages2().take(10);
  await for (final message in messageStream2) {
    print(message);
  }

  print('-----------------');

  // User-Bot Two Way Communication Setup
  await startConversation();
}

Stream<String> getMessages1() {
  // `getMessages1` creates a stream of string messages by spawning an isolate (`_getMessages`) that sends strings to a `ReceivePort`. It yields each message received on the port until a non-String item is encountered.
  final receivePort = ReceivePort();
  return Isolate.spawn(_getMessages, receivePort.sendPort)
      .asStream()
      .asyncExpand((_) => receivePort)
      .takeWhile((element) => element is String)
      .cast<String>();
}

Stream<String> getMessages2() async* {
  // `getMessages2` creates a stream of string messages by spawning an isolate (`_getMessages`) that sends strings to a `ReceivePort`. It yields each message received on the port until a non-String item is encountered.
  final receivePort = ReceivePort();
  await Isolate.spawn(_getMessages, receivePort.sendPort);
  await for (final now
      in receivePort.takeWhile((element) => element is String).cast<String>()) {
    yield now;
  }
}

void _getMessages(SendPort sendPort) async {
  // `_getMessages` is an Isolate worker function that sends the current time as an ISO-8601 string to the provided `SendPort`. It generates the time strings periodically every 200ms.
  await for (final now in Stream.periodic(
    Duration(milliseconds: 200),
    (_) => DateTime.now().toIso8601String(),
  )) {
    sendPort.send(now);
  }
}

const messagesAndResponses = {
  '': 'Ask me anything!',
  'Hello': 'Hi!',
  'Hi': 'Hello!',
  'How are you?': 'I\'m fine!',
  'What\'s up?': 'Nothing much.',
  'What are you doing?': 'I\'m busy learning Isolates in Dart.',
  'What is the meaning of life?': '42.',
  'Are you a bot?': 'Hell yeah!',
  'Are you having fun?': 'Yeah sure!',
};

Future<void> startConversation() async {
  // `startConversation` is the main entry point for initiating the interaction between the user and the bot. It starts by creating a new isolate that will handle the responses to user inputs.
  // This function listens on a `ReceivePort` for messages from the isolate, which can either be a `SendPort` or a bot response. When a `SendPort` message is received, it completes a `Completer` with the `SendPort`, allowing the main isolate to send user inputs to the response isolate.
  // When a bot response is received, it prints the response and prompts the user for more input. It ensures that the user input process is initiated after the `Completer` is completed with the `SendPort`.
  final receivePort = ReceivePort();
  final completer = Completer<SendPort>();
  await Isolate.spawn(_responseCalculator, receivePort.sendPort);

  receivePort.listen((message) async {
    if (message is SendPort) {
      completer.complete(message);
    } else {
      print('Bot: $message');
      await _processUserInput(completer.future);
    }
  });

  await _processUserInput(completer.future);
}

Future<void> _processUserInput(Future<SendPort> sendPortFuture) async {
  // This function is responsible for reading input from the user via the command line. After prompting the user with "User: ", it waits for the user to enter a string and press Enter. If the user types 'exit', the program terminates. Otherwise, it retrieves the SendPort from the future provided as an argument and sends the user's input to it. This SendPort is connected to an isolate which will process the input or handle it further.
  stdout.write('User: ');
  final userInput = stdin.readLineSync();
  if (userInput != null && userInput != 'exit') {
    final sendPort = await sendPortFuture;
    sendPort.send(userInput);
  } else {
    exit(0);
  }
}

void _responseCalculator(SendPort sendPort) async {
  // The _responseCalculator function is an entry point for an isolate which handles user input and provides a corresponding response. It establishes two-way communication between the main isolate and the new isolate by sending its own SendPort to the main isolate. It then listens for incoming messages (user input) on its ReceivePort. For each message received, it looks up a predefined response from the messagesAndResponses map. If the message is not recognized, it defaults to a generic response. The response is then sent back to the main isolate through the SendPort.
  final receivePort = ReceivePort();
  sendPort.send(receivePort.sendPort);

  await for (final userInput in receivePort) {
    final response =
        messagesAndResponses[userInput] ?? 'Ask me something else!';
    sendPort.send(response);
  }
}
